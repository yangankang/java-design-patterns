### 自我介绍及工作经历。
1.简单介绍自己的情况
2.简单介绍工作的公司已经在公司里都做过哪些东西
3.个人对编程的业余爱好或者创造性的东西比如框架等等等
### 自己优势技术在哪些方面。

### 用过哪些中间件。
dubbo、zookeeper、MQ、kafka

### 做过工作流引擎没有。

### NIO的底层实现。
linux: select、poll、epoll
bsd: select、poll、kqueue
windows: winsock2的select

select的缺点:
1.单个进程监控的文件描述符有限，通常为1024*8个文件描述符。
当然可以改进，由于select采用轮询方式扫描文件描述符。文件描述符数量越多，性能越差。
2.内核/用户数据拷贝频繁，操作复杂。
select在调用之前，需要手动在应用程序里将要监控的文件描述符添加到fed_set集合中。然后加载到内核进行监控。用户为了检测时间是否发生，
还需要在用户程序手动维护一个数组，存储监控文件描述符。当内核事件发生，在将fed_set集合中没有发生的文件描述符清空，然后拷贝到用户区，
和数组中的文件描述符进行比对。再调用selecct也是如此。每次调用，都需要了来回拷贝。
3.轮回时间效率低
select返回的是整个数组的句柄。应用程序需要遍历整个数组才知道谁发生了变化。轮询代价大。
4、select是水平触发
应用程序如果没有完成对一个已经就绪的文件描述符进行IO操作。那么之后select调用还是会将这些文件描述符返回，通知进程。

poll特点:
1.poll操作比select稍微简单点。select采用三个位图来表示fd_set，poll使用pollfd的指针
pollfd结构包含了要监视的event和发生的evevt，不再使用select传值的方法。更方便
2.select的缺点依然存在。
拿select为例，加入我们的服务器需要支持100万的并发连接。则在FD_SETSIZE为1024的情况下，我们需要开辟100个并发的进程才能实现并发连接。
除了进程上下调度的时间消耗外。从内核到用户空间的无脑拷贝，数组轮询等，也是系统难以接受的。因此，基于select实现一个百万级别的并发访问是
很难实现的。

epoll模型:
由于epoll和上面的实现机制完全不同，所以上面的问题将在epoll中不存在。
在select/poll中，服务器进程每次调用select都需要把这100万个连接告诉操作系统（从用户态拷贝到内核态）。让操作系统检测这些套接字是否有
时间发生。轮询完之后，再将这些句柄数据复制到操作系统中，让服务器进程轮询处理已发生的网络时间。这一过程耗时耗力，
而epoll通过在linux申请一个建议的文件系统，把select调用分为了三部分。
1）调用epoll_create建立一个epoll对象，这个对象包含了一个红黑树和一个双向链表。并与底层建立回调机制。
2）调用epoll_ctl向epoll对象中添加这100万个连接的套接字
3）调用epoll_wait收集发生事件的连接。
从上面的调用方式就可以看到epoll比select/poll的优越之处：因为后者每次调用时都要传递你所要监控的所有socket给select/poll系统调用，
这意味着需要将用户态的socket列表copy到内核态，如果以万计的句柄会导致每次都要copy几十几百KB的内存到内核态，非常低效。而我们调用
epoll_wait时就相当于以往调用select/poll，但是这时却不用传递socket句柄给内核，因为内核已经在epoll_ctl中拿到了要监控的句柄列表。
所以，实际上在你调用epoll_create后，内核就已经在内核态开始准备帮你存储要监控的句柄了，每次调用epoll_ctl只是在往内核的数据结构里塞
入新的socket句柄。
在内核里，一切皆文件。所以，epoll向内核注册了一个文件系统，用于存储上述的被监控socket。当你调用epoll_create时，就会在这个虚拟的
epoll文件系统里创建一个file结点。当然这个file不是普通文件，它只服务于epoll。
epoll在被内核初始化时（操作系统启动），同时会开辟出epoll自己的内核高速cache区，用于安置每一个我们想监控的socket，这些socket会
以红黑树的形式保存在内核cache里，以支持快速的查找、插入、删除。这个内核高速cache区，就是建立连续的物理内存页，然后在之上建立slab
层，简单的说，就是物理上分配好你想要的size的内存对象，每次使用时都是使用空闲的已分配好的对象。
epoll的高效:
epoll的高效就在于，当我们调用epoll_ctl往里塞入百万个句柄时，epoll_wait仍然可以飞快的返回，并有效的将发生事件的句柄给我们用户。这是由于我们在调用epoll_create时，内核除了帮我们在epoll文件系统里建了个file结点，在内核cache里建了个红黑树用于存储以后epoll_ctl传来的socket外，还会再建立一个list链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可。有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没数据也返回。所以，epoll_wait非常高效。
而且，通常情况下即使我们要监控百万计的句柄，大多一次也只返回很少量的准备就绪句柄而已，所以，epoll_wait仅需要从内核态copy少量的句柄到用户态而已，如何能不高效？！

### JVM基础（必问），JVM GC原理，JVM怎么实现回收内存。
1）第一次GC时Survivous中S0区和S1区都为空，将其中一个作为To Survivous(用来存储Eden区域执行GC后不能被回收的对象)。
比如：将S0作为To Survivous，则S1为From Survivous。
2）将Eden区域经过GC不能被回收的对象存储到To Survivous（S0）区域（此时Eden区域的内存会在垃圾回收的过程中全部释放），
但如果To Survivous（S0）被占满了，Eden中剩下不能被回收对象只能存放到Old区域。
3）将Eden区域空间清空，此时From Survivous区域（S1）也是空的。
4）S0与S1互相切换标签，S0为From Survivous，S1为To Survivous。

### 线程池原理是怎样的？
### 锁的机制升降级。
### Dubbo原理、以及序列化等相关问题。
### Dubbo如何一条链接并发多个调用。
### 说说你对分布式事务一致性的理解。
### 从系统层面考虑，分布式应该考虑哪些纬度。
### 微信红包的实现原理。
### 海量数据分析怎样实现。
### API接口（提供给他人使用）与SDI接口的区别是什么。
### 如何实现Hadoop底层（天猫）
### threadLocal，线程池，hashMap/hashTable/coccurentHashMap等（天猫）
### 谈谈如何设计秒杀系统。
### 虚拟机、IO等相关知识点。
### Linux命令。
### 一个整形数组，给定一个数，在数组中找出两个数的和等于这个数，并打印出来，我写的时间复杂度高，要求O(n)。
### n个整数，找出连续的m个数加和是最大。
### 开源技术了解多少。
### 1000个线程同时运行，怎么防止不卡。
### 并列的并发消费问题。
### 大量高并发量情况下，如何处理热点、数据等。
### 如何获取一个本地服务器上可用的端口。
### 流量控制相关问题。
### 数据库TPS是多少。
### 数据库锁隐的原理。
### 分布式锁、Redis缓存，Spring aop，系统架构图，MySQL的特性。
### 缓存击穿的解决方案有哪些。
### Java怎么挖取回收器相关原理。
### Java集合都有哪些，以及其特点是什么。
### 高并发场景相关题目：同时给10万个人发工资，你会怎么去设计并发方案，以确保在1分钟内全部发完，打个比方会提出类似的场景。
### 
### Java事件机制包括哪三个部分？分别介绍下。
### 使用线程池的原因？
### 线程池的作用有哪些？
### 几种常见的线程池及其各自的使用场景是怎样的。
### 线程池都有哪几种工作队列？
### 怎么理解无界队列和有界队列？
### 线程池中的几种重要的参数及流程说明。
### 什么是反射机制？
### 说说反射机制的作用。
### 反射机制会不会有性能问题？
### 你怎么理解http协议？
### 说说http协议的工作流程。
### http有哪些请求提交方式？
### http中的200,302,403,404,500,503都代表什么状态？
### http get和post有什么区别？
### 你怎么理解cookie和session，有哪些不同点？
### 什么是web缓存？有什么优点？
### 什么是https，说说https的工作原理？
### 什么是http代理服务器，有什么用？
### 什么是虚拟主机及实现原理？
### 什么是Java虚拟机，为什么要使用？
### 说说Java虚拟机的生命周期及体系结构。
### 说一说Java内存区域。
### 什么是分布式系统？
### 分布式系统你会考虑哪些方面？
### 为什么说TCP/IP协议是不可靠的？
### OSI有哪七层模型？TCP/IP是哪四层模型。
### TCP协议的三次握手，四次挥手流程。
（1）第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。
（2）第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。
（3）第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。

（1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。
（2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。
（3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。
（4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。

### 为什么TCP建立连接协议是三次握手，而关闭连接却是四次握手呢？为什么不能用两次握手进行连接？
因为TCP是全双工通信的
（1）第一次挥手：因此当主动方发送断开连接的请求（即FIN报文）给被动方时，仅仅代表主动方不会再发送数据报文了，但主动方仍可以接收数据报文。
（2）第二次挥手：被动方此时有可能还有相应的数据报文需要发送，因此需要先发送ACK报文，告知主动方“我知道你想断开连接的请求了”。这样主动方便不会因为没有收到应答而继续发送断开连接的请求（即FIN报文）。
（3）第三次挥手：被动方在处理完数据报文后，便发送给主动方FIN报文；这样可以保证数据通信正常可靠地完成。发送完FIN报文后，被动方进入LAST_ACK阶段（超时等待）。
（4）第四次挥手：如果主动方及时发送ACK报文进行连接中断的确认，这时被动方就直接释放连接，进入可用状态。
### 为什么TCP TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？
### 什么是DoS、DDoS、DRDoS攻击？如何防御？
DOS：中文名称是拒绝服务，一切能引起DOS行为的攻击都被称为DOS攻击。该攻击的效果是使得计算机或网络无法提供正常的服务。常见的DOS攻击有针对计算机网络带宽和连通性的攻击。 DOS是单机于单机之间的攻击。
DDOS：中文名称是分布式拒绝服务攻击。指的是攻击者控制多台主机同时向同一主机或网络发起DOS攻击。
DRDoS：分布反射式拒绝服务攻击这是DDoS攻击的变形，它与DDoS的不同之处就是DrDoS不需要在攻击之前占领大量的“肉鸡”。

### 描述一下Java异常层次结构。
### 什么是检查异常，不受检查异常，运行时异常？并分别举例说明。
### finally块一定会执行吗？
try finally时只要jvm不退出或者不死掉就一定会执行
### 正常情况下，当在try块或catch块中遇到return语句时，finally语句块在方法返回之前还是之后被执行？
### try、catch、finally语句块的执行顺序。
### Java虚拟机中，数据类型可以分为哪几类？
基本类型和引用类型
### 怎么理解栈、堆？堆中存什么？栈中存什么？
栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值和局部变量的值等。其操作方式类似于数据结构中的栈。简单的理解就是当定义一个变量的时候，
计算机会在内存中开辟一块存储空间来存放这个变量的值，这块空间就叫做栈，然而栈中一般存放的是基本类型数据，栈的特点是先进后出（或后进先出）
堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。其实在堆中一般存放变量是一些对象类型

堆中存的是对象。栈中存的是基本数据类型和堆中对象的引用。一个对象的大小是不可估计的，或者说是可以动态变化的，
但是在栈中，一个对象只对应了一个4btye的引用(堆栈分离的好处)
### 为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？
第一，从软件设计的角度看，栈代表了处理逻辑，而堆代表了数据。这样分开，使得处理逻辑更为清晰。分而治之的思想。这种隔离、模块化的思想在软件设计
的方方面面都有体现。
第二，堆与栈的分离，使得堆中的内容可以被多个栈共享（也可以理解为多个线程访问同一个对象）。这种共享的收益是很多的。一方面这种共享提供了
一种有效的数据交互方式(如：共享内存)，另一方面，堆中的共享常量和缓存可以被所有栈访问，节省了空间。
第三，栈因为运行时的需要，比如保存系统运行的上下文，需要进行地址段的划分。由于栈只能向上增长，因此就会限制住栈存储内容的能力。而堆不同，
堆中的对象是可以根据需要动态增长的，因此栈和堆的拆分，使得动态增长成为可能，相应栈中只需记录堆中的一个地址即可。
第四，面向对象就是堆和栈的完美结合。其实，面向对象方式的程序与以前结构化的程序在执行上没有任何区别。但是，面向对象的引入，使得对待问题的
思考方式发生了改变，而更接近于自然方式的思考。当我们把对象拆开，你会发现，对象的属性其实就是数据，存放在堆中；而对象的行为（方法），就是
运行逻辑，放在栈中。我们在编写对象的时候，其实即编写了数据结构，也编写的处理数据的逻辑。不得不承认，面向对象的设计，确实很美。

### 在Java中，什么是是栈的起始点，同是也是程序的起始点？
程序要运行总是有一个起点的。同C语言一样，java中的Main就是那个起点。无论什么java程序，找到main就找到了程序执行的入口

### 为什么不把基本类型放堆中呢？
为什么不把基本类型放堆中呢？因为其占用的空间一般是1~8个字节——需要空间比较少，而且因为是基本类型，所以不会出现动态增长的情况——长度固定，
因此栈中存储就够了，如果把他存在堆中是没有什么意义的（还会浪费空间，后面说明）。可以这么说，基本类型和对象的引用都是存放在栈中，而且都
是几个字节的一个数，因此在程序运行时，他们的处理方式是统一的。但是基本类型、对象引用和对象本身就有所区别了，因为一个是栈中的数据一个是
堆中的数据。最常见的一个问题就是，Java中参数传递时的问题。

### Java中的参数传递时传值呢？还是传引用？
基本数据类型是传值，对象类型传的是引用拷贝

### Java中有没有指针的概念？
没有指针概念，但是可以通过unsafe获取对象内存地址

### Java中，栈的大小通过什么参数来设置？
-Xmx –Xms：指定最大堆和最小堆
-Xmn 设置新生代大小 -XX:NewRatio 新生代（eden+2*s）和老年代（不包含永久区）的比值 -XX:SurvivorRatio（幸存代） 设置两个Survivor区和eden的比值
-Xss 设置栈空间的大小

### 一个空Object对象的占多大空间？
32位系统 4(引用)+16=20 64位系统 8(引用)+16=24
### 对象引用类型分为哪几类？
强引用 弱引用 软引用 虚引用
### 讲一讲垃圾回收算法。
### 如何解决内存碎片的问题？
### 如何解决同时存在的对象创建和对象回收问题？
### 讲一讲内存分代及生命周期。
### 什么情况下触发垃圾回收？
### 如何选择合适的垃圾收集算法？
### JVM有哪三种垃圾回收器？
收集器	            串行、并行or并发	新生代/老年代	算法	目标	适用场景
Serial	            串行	            新生代	    复制算法	响应速度优先	单CPU环境下的Client模式
Serial Old	        串行	            老年代	    标记-整理	响应速度优先	单CPU环境下的Client模式、CMS的后备预案
ParNew	            并行	            新生代	    复制算法	响应速度优先	多CPU环境时在Server模式下与CMS配合
Parallel Scavenge	并行	            新生代	    复制算法	吞吐量优先	在后台运算而不需要太多交互的任务
Parallel Old	    并行	            老年代	    标记-整理	吞吐量优先	在后台运算而不需要太多交互的任务
CMS	                并发          	老年代	    标记-清除	响应速度优先	集中在互联网站或B/S系统服务端上的Java应用
G1	                并发	            both	    标记-整理+复制算法	响应速度优先	面向服务端应用，将来替换CMS
### JVM中最大堆大小有没有限制？
### 如何进行JVM调优？有哪些方法？
### 堆大小通过什么参数设置？
-Xmx –Xms：指定最大堆和最小堆
### 吞吐量优先选择什么垃圾回收器？响应时间优先呢？
### 如何理解内存泄漏问题？有哪些情况会导致内存泄露？如何解决？
### 从分布式系统部署角度考虑，分哪几层？
一、通信，这个任务包括设计适当的网络间进程通信机制，一些样例机制：远程过程调用（RPC）、远程对象调用（ROI）、面向流的通信和面向消息的通信，
底层通信机制的实现。
二、进程、设计的问题包括：在客户端服务端的进程和线程管理、代码迁移、软件和代理对象的设计等、
三、命名。为了以透明盒可扩展的方式来定位资源的进程，设计一个易于的名字分配标识符和地址是必不可少的。在移动系统中进行命名带来了进一步挑战，
这是由于名字是不能容易绑定到任何静态地地理拓扑上。
四、同步。在进程之间的同步与合作机制是必不可少的。互斥是同步的典型例子，但还需要许多其他形式的同步，如领导者选举。此外，物理时钟的同步，能
对所经过时间的本质进行刻画的逻辑时钟，以及全局记录算法，这些都需要不同形式的同步机制。
五、数据存储和访问。数据存储的方式以及所隐含的通过网络对数据的快速和可扩展的访问机制，是影响性能的重要因素。文件系统设计的一些传统问题在分
布式系统环境下需要重新考虑。
六、一致性与副本。为了避免出现瓶颈，提供数据的快速访问以及提供可扩展性，对数据对象进行复制是非常必要的。这会导致出现管理副本的问题，以及在
分布式环境下维护副本/缓存之间一致性问题。一个简单的例子就是如何取舍数据访问粒度。（大小）
七、容错。容错机制就是在任何连接、节点、进程错误的情况下保持操作正确、高效、弹性过程、可靠的通信、分布式提交、检查点和恢复、协商和共识、故
障检测等一定容错的机制。
八、安全。分布式系统的安全包括安全通道、控制访问、密钥管理-生成、分发以及认证。
九、API透明性，易于使用的通信等专业化服务的api对分布式系统服务被非专业用户广泛接受是很重要的。透明性用来隐藏实现策略，避免让使用者卷进细节，
可以按照下面方式分类。类似于dubbo中服务暴露的过程。
十、可扩展性和模块化。算法、数据（对象）以及服务必须尽可能地分布。诸如复制、缓存、缓存管理和异步处理等技术能够增加可扩展性。
### 如何解决业务层的数据访问问题？
传统数据的访问是面向过程的，分为connection、statement、通过statement的参数sql语句来访问数据库，返回数据进行处理。
传统数据库访问模式缺点显而易见 
1、各个模块间的耦合太紧，statement要依赖connection，connection还依赖数据库的种类。
2、如果我改变的数据库种类，或者提供不同的数据库服务，那么我就要提供大量的复制代码。
使用dao与service分层后，dao叫数据访问层，全称data access object属于一种比较底层基础的操作，具体到对于某个表，某个实体的增删改查。
service被称为服务层，被称之为服务，相比之下是一个比较高层次的结构，相当于把几种操作封装起来，service层要使用接口来定义的几点好处： 
由ServiceImpl继承service接口进行业务操作。
1、在java接口是多继承的，而类是单继承的，如果你需要一个实现类实现多个Service你用接口可以实现，用接口实现没那么灵活。
2、要提供不同的数据库服务时，我们只需要面对接口用不同的实现类即可，而不是重复的定义类。
3、编程规范问题，接口化的编程就是将实现封装起来，然后调用者只关心接口不关心实现。（dao只是封装了一个个数据库的调用方法，service只是在
dao层上进行了一层包装实现相对高级的操作，最后将这些操作再ServiceImpl类中实现）（简而言之：好处就是如果 业务层需要修改无需改变dao层的
代码，数据库访问有了新需求也不需要在service去改动）

### 为了解决数据库服务器的负担，如何做数据库的分布？
### 什么是著名的拜占庭将军问题？
### 讲讲CAP理念。
1、一致性(Consistency)：服务A、B、C三个结点都存储了用户数据， 三个结点的数据需要保持同一时刻数据一致性。
2、可用性(Availability)：服务A、B、C三个结点，其中一个结点宕机不影响整个集群对外提供服务，如果只有服务A结点，当服务A宕机整个系统将无法提
供服务，增加服务B、C是为了保证系统的可用性。
3、分区容忍性(Partition Tolerance)：分区容忍性就是允许系统通过网络协同工作，分区容忍性要解决由于网络分区导致数据的不完整及无法访问等问题。

1、CA：放弃分区容忍性，加强一致性和可用性，关系数据库按照CA进行设计。
2、AP：放弃一致性，加强可用性和分区容忍性，追求最终一致性，很多NoSQL数据库按照AP进行设计。
说明：这里放弃一致性是指放弃强一致性，强一致性就是写入成功立刻要查询出最新数据。追求最终一致性是指允许暂时的数据不一致，只要最终在用户接受的时间
内数据 一致即可
3、CP：放弃可用性，加强一致性和分区容忍性，一些强一致性要求的系统按CP进行设计，比如跨行转账，一次转账请求要等待双方银行系统都完成整个事务才算完成。
### 怎么理解强一致性、单调一致性和最终一致性？
1、强一致性（Strong Consistency）
在任何时刻所有的用户或者进程查询到的都是最近一次成功更新的数据。强一致性是程度最高一致性要求，也是最难实现的。关系型数据库更新操作就是这个案例。

2， 单调一致性（Monotonic Consistency）
单调一致性会从读写两个角度有各自的定义。
单调读一致性：如果进程已经看到过数据对象的某个值，那么任何后续访问都不会返回该值之前的值。
单调写一致性：系统保证来自同一个进程的写操作顺序执行。

手机刷虎扑的时候经常遇到，回复某人的帖子然后想马上查看，但我刚提交的回复可能尚未到达从库，看起来好像是刚提交的数据丢失了，很不爽。
在这种情况下，我们需要读写一致性，也称为读己之写一致性。它可以保证，如果用户刷新页面，他们总会看到自己刚提交的任何更新。它不会对其他用
户的写入做出承诺，其他用户的更新可能稍等才会看到，但它保证用户自己提交的数据能马上被自己看到。

3、最终一致性（Eventual Consistency）
和强一致性相对，在某一时刻用户或者进程查询到的数据可能都不同，但是最终成功更新的数据都会被所有用户或者进程查询到。当前主流的nosql数据库都是采用这种一致性策略。
### 分布式系统设计你会考虑哪些策略？
如何检测你还活着？如何保障高可用？容错处理？重试机制？负载均衡？
1. 心跳检测：在分布式环境中，一般会有多个节点来分担任务的运行、计算或程序逻辑处理。通常采用 心跳检测 来判断节点是否可用。
2. 高可用设计：系统高可用性的常用设计模式包括三种：主备（Master-Slave）模式、互备（Active-Active）模式和集群（Cluster）模式。
3. 容错性：容错就是IT系统对于错误的包容能力，确切地说是容故障而非错误。容错的处理是保障分布式环境下相应系统的高可用或者健壮性。
4. 负载均衡集群：其关键在于使用多台集群服务器共同分担计算任务，把网络请求及计算分配到集群可用服务器上去，从而达到可用性及较好地用户体验。

### 最常见的数据分布方式是什么？
1.哈希方式 2.按数据范围方式 3.一致性哈希
### 谈一谈一致性哈希算法。
### paxos是什么？
Paxos用于解决分布式系统中一致性问题。分布式一致性算法（Consensus Algorithm）是一个分布式计算领域的基础性问题
，其最基本的功能是为了在多个进程之间对某个（某些）值达成一致（强一致）
### 什么是Lease机制？
### 如何理解选主算法？


### 1.mysql的三大引擎是啥？
mysql常用的引擎有InnoDB，MyISAM，Memory，默认是InnoDB
InnoDB：磁盘表，支持事务，支持行级锁，B+Tree索引
ps:优点： 具有良好的ACID特性。适用于高并发，更新操作比较多的表。需要使用事务的表。对自动灾难恢复有要求的表。
缺点：读写效率相对MYISAM比较差。占用的磁盘空间比较大。
mysql的4大特性+4种隔离级别：
MyISAM：磁盘表，不支持事务，支持表级锁，B+Tree索引
ps: 优点：占用空间小，处理速度快（相对InnoDB来说）
缺点：不支持事务的完整性和并发性
MEMORY(Heap)：内存表，不支持事务，表级锁，Hash索引，不支持Blob,Text大类型
ps: 优点：速度要求快的，临时数据
缺点：丢失以后，对项目整体没有或者负面影响不大的时候。

### 2.redis的hash算法用的是啥？
redis应该是使用一致性hash算法---MurmurHash3 算法，具有低碰撞率优点，google改进的版本cityhash也是redis中用到的哈希算法。
现有的主流的大数据系统都是用的 MurmurHash本身或者改进。

### 3.Nosql为啥比sql快？
Nosql是非关系型数据库，因为不需要满足关系数据库数据一致性等复杂特性所以速度快；
SQL是关系型数据库，功能强大，但是效率上有瓶颈。

### 4.什么是索引？
索引分为聚簇索引和非聚簇索引两种，聚簇索引是按照数据存放的物理位置为顺序的，而非聚簇索引就不一样了；聚簇索引能提高多行检索的速度，而非聚簇索引对于单行的检索很快。
聚簇索引：有主键时，根据主键创建聚簇索引；没有主键时，会用一个唯一且不为空的索引列做为主键，成为此表的聚簇索引；如果以上两个都不满足那innodb自己创建一个虚拟的聚集索引
非聚簇索引：非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引。

### 5.B+树和B树区别？
B树的非叶子节点存储实际记录的指针，而B+树的叶子节点存储实际记录的指针
B+树的叶子节点通过指针连起来了, 适合扫描区间和顺序查找。
